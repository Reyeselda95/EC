* XC3000.LIB

.MODEL D0_TGATE UTGATE ()

.MODEL D0_GATE UGATE ()

.MODEL D0_EFF UEFF ()

.MODEL D0_GFF UGFF ()

* Xilinx X3000 I/O models

.param X3000_VDD 5.0V
.param X3000_VSS 0.0V

.subckt X3000_PWR  AGND
+	optional: VDD=$G_X3000_VDD VSS=$G_X3000_VSS
+	params:   VOLTAGE={X3000_VDD} REFERENCE={X3000_VSS}
*
VVDD  VDD VSS   {VOLTAGE}
R1    VDD AGND  1MEG
VVSS  VSS AGND  {REFERENCE}
R2    VSS AGND  1MEG
.ends
*$

.model IO_X3000 uio (
+	drvh=1649	drvl=1649
+	AtoD1="AtoD_X3000"	AtoD2="AtoD_X3000"
+	AtoD3="AtoD_X3000"	AtoD4="AtoD_X3000"
+	DtoA1="DtoA_X3000"	DtoA2="DtoA_X3000"
+	DtoA3="DtoA_X3000"	DtoA4="DtoA_X3000"
+       tswhl1=7.07ns		tswlh1=8.58ns
+       tswhl2=6.94ns		tswlh2=8.37ns
+       tswhl3=9.33ns		tswlh3=10.73ns
+       tswhl4=9.18ns		tswlh4=10.59ns
+	DIGPOWER="X3000_PWR"
+	)
*$

.model IO_X3000_OC uio (
+	drvh=20K	drvl=1649
+	AtoD1="AtoD_X3000"	AtoD2="AtoD_X3000"
+	AtoD3="AtoD_X3000"	AtoD4="AtoD_X3000"
+	DtoA1="DtoA_X3000"	DtoA2="DtoA_X3000"
+	DtoA3="DtoA_X3000"	DtoA4="DtoA_X3000"
+       tswhl1=7.07ns		tswlh1=8.58ns
+       tswhl2=6.94ns		tswlh2=8.37ns
+       tswhl3=9.33ns		tswlh3=10.73ns
+       tswhl4=9.18ns		tswlh4=10.59ns
+	DIGPOWER="X3000_PWR"
+	)
*$

.model IO_X3000_PULLUP uio (
+	drvh=5K	drvl=1649
+	AtoD1="AtoD_X3000"	AtoD2="AtoD_X3000"
+	AtoD3="AtoD_X3000"	AtoD4="AtoD_X3000"
+	DtoA1="DtoA_X3000"	DtoA2="DtoA_X3000"
+	DtoA3="DtoA_X3000"	DtoA4="DtoA_X3000"
+       tswhl1=7.07ns		tswlh1=8.58ns
+       tswhl2=6.94ns		tswlh2=8.37ns
+       tswhl3=9.33ns		tswlh3=10.73ns
+       tswhl4=9.18ns		tswlh4=10.59ns
+	DIGPOWER="X3000_PWR"
+	)
*$

.subckt AtoD_X3000  A D  DPWR DGND
+	params: CAPACITANCE=0
*
XNORM A NORM DPWR DGND AtoD_NORM_X3000
O0  NORM DGND DOX3000 DGTLNET=D IO_X3000
C1  A DGND {CAPACITANCE+0.1pF}
D1  DGND A    D74CLMP
D2  A    DPWR D74CLMP
.ends
*$
.subckt DtoA_X3000  D A  DPWR DGND
+	params: DRVL=0 DRVH=0 CAPACITANCE=0
*
X1  DPWR DGND DRVPWR DRVGND DtoA_DRIVE_X3000 
N1  A DRVGND DRVPWR DINX3000 DGTLNET=D IO_X3000
C1  A DGND {CAPACITANCE+0.1pF}
.ends
*$
*-------------------------------------------------
* X3000 Input Voltage Normilization Subcircuit
*
* This circuit normalizes the input voltage, so that
* voltages below -0.5 are '0', and above +0.5 are '1'.
* The EVt device "looks up" the threshold voltage for the 
* current power supply voltage in the table.  The data for the
* table comes from the minimum and maximum voltage transfer
* characteristics graph for the X3000.

.subckt AtoD_NORM_X3000 A ANORM DPWR DGND
*
EVt THRESHOLD 0 TABLE {V(DPWR,DGND)} = 1.5,0 3.5,0.6 5,1.5 10,3 15,4
RVt THRESHOLD 0 100k
EN  ANORM DGND VALUE = {(V(A,DGND)-V(DPWR,DGND)/2)/((V(DPWR,DGND)-2*V(THRESHOLD))+1u)}
RN  ANORM DGND 100k
Rld1 A DPWR 100MEG
Rld2 A DGND 100MEG
.ends
*$
*-------------------------------------------------
* X3000 Output Drive Subcircuit
*
* This circuit constructs the correct output drive
* resistance for the power supply voltage.  This resistance is inserted
* in series with the digital input device, and the digital input device 
* resistance is set to a low value when it is on.  The tables provide the 
* output current at 1v VDS for various values of VDD (3V is an estimate)
* from the X3000

.subckt DtoA_DRIVE_X3000 DPWR DGND DRVPWR DRVGND
*
EDRVP DRVP 0 TABLE {V(DPWR,DGND)} = 1.5,0mA 3,0.5mA 5,1.2mA 10,2.0mA 15,3.0mA
EDRVN DRVN 0 TABLE {V(DPWR,DGND)} = 1.5,0mA 3,0.5mA 5,1.5mA 10,4.0mA 15,7.0mA
RDRVP DRVP 0 1K
RDRVN DRVN 0 1K
GPWR DPWR DRVPWR VALUE = {V(DPWR,DRVPWR)*V(DRVP)}
GGND DRVGND DGND VALUE = {V(DRVGND,DGND)*V(DRVN)}
RDUM1 DPWR DRVPWR 100MEG
RDUM2 DGND DRVGND 100MEG
.ends
*$
*-------------------------------------------------
* X3000 Digital Input/Output Models

.model DINX3000 dinput (
+	s0name="0"	s0tsw=15ns	s0rlo=1 	s0rhi=80K
+	s1name="1"	s1tsw=15ns	s1rlo=40K	s1rhi=1
+	s2name="X"	s2tsw=15ns	s2rlo=800	s2rhi=800
+	s3name="R"	s3tsw=15ns	s3rlo=800	s3rhi=800
+	s4name="F"	s4tsw=15ns	s4rlo=800	s4rhi=800
+	s5name="Z"	s5tsw=15ns	s5rlo=1MEG	s5rhi=1MEG
+	)
*$
.model DOX3000 doutput (
+	s0name="X"	s0vlo=-0.5	s0vhi=0.5
+	s1name="0"	s1vlo=-3.0	s1vhi=-0.5
+	s2name="R"	s2vlo=-0.5	s2vhi=0.05
+	s3name="R"	s3vlo=-0.05	s3vhi=0.5
+	s4name="X"	s4vlo=-0.5	s4vhi=0.5
+	s5name="1"	s5vlo= 0.5	s5vhi=3.0
+	s6name="F"	s6vlo=-0.05	s6vhi=0.5
+	s7name="F"	s7vlo=-0.5	s7vhi=0.05
+	)
*$

.SUBCKT X3_BUF IN PI OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: IN_D=0 OUT_D=0

U1 LOGICEXP(3,1) DPWR DGND 
+ IN PI PO OUT
+ X3_BUF
+ IO_X3000
+ LOGIC:
+   OUT = {PO ^ (IN^PI) }

.MODEL X3_BUF UGATE (
+  TPLHMN={IN_D+OUT_D} TPHLMN={IN_D+OUT_D}
+  TPLHMX={IN_D+OUT_D} TPHLMX={IN_D+OUT_D}
+  )

.ENDS X3_BUF

.SUBCKT X3_ACLK IN PI OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: IN_D=0 OUT_D=0

U1 LOGICEXP(3,1) DPWR DGND 
+ IN PI PO OUT
+ X3_ACLK
+ IO_X3000
+ LOGIC:
+   OUT = {PO ^ (IN^PI) }

.MODEL X3_ACLK UGATE (
+  TPLHMN={IN_D+OUT_D} TPHLMN={IN_D+OUT_D}
+  TPLHMX={IN_D+OUT_D} TPHLMX={IN_D+OUT_D}
+  )

.ENDS X3_ACLK

*$

.SUBCKT X3_GCLK IN PI OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: IN_D=0 OUT_D=0

U1 LOGICEXP(3,1) DPWR DGND 
+ IN PI PO OUT
+ X3_GCLK
+ IO_X3000
+ LOGIC:
+   OUT = {PO ^ (IN^PI) }

.MODEL X3_GCLK UGATE (
+  TPLHMN={IN_D+OUT_D} TPHLMN={IN_D+OUT_D}
+  TPLHMX={IN_D+OUT_D} TPHLMX={IN_D+OUT_D}
+  )

.ENDS X3_GCLK

*$


.SUBCKT X3_BUFG IN PI OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: IN_D=0 OUT_D=0

U1 LOGICEXP(3,1) DPWR DGND 
+ IN PI PO OUT
+ X3_BUF
+ IO_X3000
+ LOGIC:
+   OUT = {PO ^ (IN^PI) }

.MODEL X3_BUF UGATE (
+  TPLHMN={IN_D+OUT_D} TPHLMN={IN_D+OUT_D}
+  TPLHMX={IN_D+OUT_D} TPHLMX={IN_D+OUT_D}
+  )

.ENDS X3_BUFG

*$

.SUBCKT X3_IBUF IN PI OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: IN_D=0 OUT_D=0
*
* PI and PO are not used
*
U1 BUF DPWR DGND 
+ IN OUT
+ X3_IBUF
+ IO_X3000

.MODEL X3_IBUF UGATE (
+  TPLHMN={IN_D+OUT_D} TPHLMN={IN_D+OUT_D}
+  TPLHMX={IN_D+OUT_D} TPHLMX={IN_D+OUT_D}
+  )

.ENDS X3_IBUF


.SUBCKT X3_INV IN PI OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: IN_D=0 OUT_D=0

U1 LOGICEXP(3,1) DPWR DGND 
+ IN PI PO OUT
+ X3_INV
+ IO_X3000
+ LOGIC:
+   OUT = {PO ^ ~(IN^PI) }

.MODEL X3_INV UGATE (
+  TPLHMN={IN_D+OUT_D} TPHLMN={IN_D+OUT_D}
+  TPLHMX={IN_D+OUT_D} TPHLMX={IN_D+OUT_D}
+  )

.ENDS X3_INV


*$

.SUBCKT X3_AND2  I0 P0 I1 P1 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 OUT_D=0

U1 LOGICEXP(5,1) DPWR DGND 
+ I0 P0 I1 P1 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) & (I1^P1) ) }

U2 PINDLY(1,0,2) DPWR DGND
+ OUT_INT
+ I0 I1
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_AND2


.SUBCKT X3_AND3  I0 P0 I1 P1 I2 P2 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 OUT_D=0

U1 LOGICEXP(7,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) & (I1^P1) & (I2^P2) ) }

U2 PINDLY(1,0,3) DPWR DGND
+ OUT_INT
+ I0 I1 I2
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_AND3


.SUBCKT X3_AND4  I0 P0 I1 P1 I2 P2 I3 P3 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 OUT_D=0

U1 LOGICEXP(9,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) & (I1^P1) & (I2^P2) & (I3^P3) ) }

U2 PINDLY(1,0,4) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_AND4


.SUBCKT X3_AND5  I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 I4_D=0 OUT_D=0

U1 LOGICEXP(11,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) & (I1^P1) & (I2^P2) & (I3^P3) & (I4^P4) ) }

U2 PINDLY(1,0,5) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3 I4
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 CHANGED(I4,0), DELAY(I4_D+OUT_D,-1,I4_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_AND5

*$

.SUBCKT X3_FDCE CLR CLK PCLK CLKENA D Q GR
+ OPTIONAL:  DPWR=$G_X3000_VDD DGND=$G_X3000_VSS 
+ PARAMS: CLR_D=0 GR_D=0 CLK_D=0 CLKENA_D=0 D_D=0 Q_D=0
+   D_CLK_SETUP=0       D_CLK_HOLD=0
+   CLR_CLK_SETUP=0     CLR_CLK_HOLD=0
+   CLKENA_CLK_SETUP=0  CLKENA_CLK_HOLD=0
+   CLK_WIDTH=0 CLR_WIDTH=0 GR_WIDTH=0

UD BUF DPWR DGND
+ D D_BUF
+ X3_FDCE_D 
+ IO_X3000
.MODEL X3_FDCE_D UGATE (
+   TPLHMN={D_D} TPLHMX={D_D}
+   TPHLMN={D_D} TPHLMX={D_D}
+   )

UCLK XOR DPWR DGND
+ CLK PCLK CLK_BUF
+ X3_FDCE_CLK 
+ IO_X3000
.MODEL X3_FDCE_CLK UGATE (
+   TPLHMN={CLK_D} TPLHMX={CLK_D}
+   TPHLMN={CLK_D} TPHLMX={CLK_D}
+   )

UCLKENA BUF DPWR DGND
+ CLKENA CLKENA_BUF
+ X3_FDCE_CLKENA 
+ IO_X3000
.MODEL X3_FDCE_CLKENA UGATE (
+   TPLHMN={CLKENA_D} TPLHMX={CLKENA_D}
+   TPHLMN={CLKENA_D} TPHLMX={CLKENA_D}
+   )

UCLR INV DPWR DGND   ; ACTIVE HI
+ CLR CLR_BUF
+ X3_FDCE_CLR 
+ IO_X3000
.MODEL X3_FDCE_CLR UGATE (
+   TPLHMN={CLR_D} TPLHMX={CLR_D}
+   TPHLMN={CLR_D} TPHLMX={CLR_D}
+   )

UGR BUF DPWR DGND   ; ACTIVE LO
+ GR GR_BUF
+ X3_FDCE_GR 
+ IO_X3000

.MODEL X3_FDCE_GR UGATE (
+   TPLHMN={GR_D} TPLHMX={GR_D}
+   TPHLMN={GR_D} TPHLMX={GR_D}
+   )

UCLRIN AND(2) DPWR DGND ; EITHER ONE GOING LOW RESETS THE DFF
+ CLR_BUF GR_BUF CLR_IN
+ D0_GATE
+ IO_X3000

UDFF DFFDE(1) DPWR DGND
+ $D_HI CLR_IN CLK_BUF CLKENA_BUF $D_LO D_BUF Q_INT $D_NC
+ D0_EFF
+ IO_X3000

UDELAY PINDLY(1,0,7) DPWR DGND
+ Q_INT
+ CLK CLK_BUF D_BUF CLKENA_BUF CLR GR GR_BUF
+ Q
+ IO_X3000
+ PINDLY:
+   Q = {DELAY(Q_D,-1,Q_D)}
+ SETUP_HOLD:
+   CLOCK LH = CLK_BUF
+   DATA(1) = D_BUF
+   SETUPTIME = {D_CLK_SETUP}
+   HOLDTIME =  {D_CLK_HOLD}
+   WHEN = {GR_BUF == '0 & CLR == '0 & CLKENA_BUF == '1}
+ SETUP_HOLD:
+   CLOCK LH = CLK_BUF
+   DATA(1) = CLKENA_BUF
+   SETUPTIME = {CLKENA_CLK_SETUP}
+   HOLDTIME = {CLKENA_CLK_HOLD}
+   WHEN = {GR_BUF == '0 & CLR == '0 & D_BUF == Q_INT}
+ SETUP_HOLD:
+   CLOCK LH = CLK_BUF
+   DATA(1) = CLR
+   SETUPTIME = {CLR_CLK_SETUP}
+   HOLDTIME = {CLR_CLK_HOLD}
+   WHEN = {CLR != '1 & GR_BUF == '0 & CLKENA_BUF == '1}
+ WIDTH:
+   NODE = CLK
+   MIN_HI = {CLK_WIDTH}
+   MIN_LO = {CLK_WIDTH}
+ WIDTH:
+   NODE = CLR
+   MIN_HI = {CLR_WIDTH}
+ WIDTH:
+   NODE = GR
+   MIN_LO = {GR_WIDTH}

.MODEL X3_FDCE_Q UEFF (
+  TPCLKQLHMN={Q_D} TPCLKQLHMX={Q_D}
+  TPCLKQHLMN={Q_D} TPCLKQHLMX={Q_D}
+  )

.ENDS X3_FDCE

*$

.SUBCKT X3_NAND2  I0 P0 I1 P1 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 OUT_D=0

U1 LOGICEXP(5,1) DPWR DGND 
+ I0 P0 I1 P1 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~( (I0^P0) & (I1^P1) ) }

U2 PINDLY(1,0,2) DPWR DGND
+ OUT_INT
+ I0 I1
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_NAND2


.SUBCKT X3_NAND3  I0 P0 I1 P1 I2 P2 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 OUT_D=0

U1 LOGICEXP(7,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~( (I0^P0) & (I1^P1) & (I2^P2) ) }

U2 PINDLY(1,0,3) DPWR DGND
+ OUT_INT
+ I0 I1 I2
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_NAND3


.SUBCKT X3_NAND4  I0 P0 I1 P1 I2 P2 I3 P3 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 OUT_D=0

U1 LOGICEXP(9,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~( (I0^P0) & (I1^P1) & (I2^P2) & (I3^P3) ) }

U2 PINDLY(1,0,4) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_NAND4


.SUBCKT X3_NAND5  I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 I4_D=0 OUT_D=0

U1 LOGICEXP(11,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~( (I0^P0) & (I1^P1) & (I2^P2) & (I3^P3) & (I4^P4) ) }

U2 PINDLY(1,0,5) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3 I4
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 CHANGED(I4,0), DELAY(I4_D+OUT_D,-1,I4_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_NAND5

*$


.SUBCKT X3_NOR2  I0 P0 I1 P1 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 OUT_D=0

U1 LOGICEXP(5,1) DPWR DGND 
+ I0 P0 I1 P1 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~( (I0^P0) | (I1^P1) ) }

U2 PINDLY(1,0,2) DPWR DGND
+ OUT_INT
+ I0 I1
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_NOR2


.SUBCKT X3_NOR3  I0 P0 I1 P1 I2 P2 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 OUT_D=0

U1 LOGICEXP(7,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~( (I0^P0) | (I1^P1) | (I2^P2) ) }

U2 PINDLY(1,0,3) DPWR DGND
+ OUT_INT
+ I0 I1 I2
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_NOR3


.SUBCKT X3_NOR4  I0 P0 I1 P1 I2 P2 I3 P3 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 OUT_D=0

U1 LOGICEXP(9,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~( (I0^P0) | (I1^P1) | (I2^P2) | (I3^P3) ) }

U2 PINDLY(1,0,4) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_NOR4


.SUBCKT X3_NOR5  I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 I4_D=0 OUT_D=0

U1 LOGICEXP(11,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~( (I0^P0) | (I1^P1) | (I2^P2) | (I3^P3) | (I4^P4) ) }

U2 PINDLY(1,0,5) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3 I4
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 CHANGED(I4,0), DELAY(I4_D+OUT_D,-1,I4_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_NOR5

*$

.SUBCKT X3_OBUF IN PI OUT
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: IN_D=0 OUT_D=0
*
* PI is not used
*
U1 BUF DPWR DGND 
+ IN OUT
+ X3_OBUF
+ IO_X3000

.MODEL X3_OBUF UGATE (
+  TPLHMN={IN_D+OUT_D} TPHLMN={IN_D+OUT_D}
+  TPLHMX={IN_D+OUT_D} TPHLMX={IN_D+OUT_D}
+  )

.ENDS X3_OBUF


.SUBCKT X3_OBUFT IN PI T PT OUT
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: IN_D=0 TLH_D=0 THL_D=0 OUT_D=0 PULLUP_D=0
*
UTDLY BUF DPWR DGND T TDLY X3_OBUFT_T IO_X3000

.MODEL X3_OBUFT_T UGATE(
+  TPLHMN={TLH_D} TPHLMN={THL_D}
+  TPLHMX={TLH_D} TPHLMX={THL_D}
+  )

UENA LOGICEXP(2,1) DPWR DGND 
+ TDLY PT   ENA
+ D0_GATE IO_X3000
+ LOGIC:
+   ENA = { ~((TDLY ^ PT) ) }  ; XILINX 3-states are active-low enable

UIDLY BUF DPWR DGND IN INBUF X3_OBUFT_IN IO_X3000
.MODEL X3_OBUFT_IN UGATE(
+  TPLHMN={IN_D+OUT_D} TPHLMN={IN_D+OUT_D} 
+  TPLHMX={IN_D+OUT_D} TPHLMX={IN_D+OUT_D} 
+  )

UIN XOR DPWR DGND INBUF PI INNEW D0_GATE IO_X3000

UOUT BUF3 DPWR DGND 
+ INNEW ENA OUT
+ D0_TGATE
+ IO_X3000

.ENDS X3_OBUFT


.SUBCKT X3_OR2  I0 P0 I1 P1 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 OUT_D=0

U1 LOGICEXP(5,1) DPWR DGND 
+ I0 P0 I1 P1 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) | (I1^P1) ) }

U2 PINDLY(1,0,2) DPWR DGND
+ OUT_INT
+ I0 I1
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_OR2


.SUBCKT X3_OR3  I0 P0 I1 P1 I2 P2 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 OUT_D=0

U1 LOGICEXP(7,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) | (I1^P1) | (I2^P2) ) }

U2 PINDLY(1,0,3) DPWR DGND
+ OUT_INT
+ I0 I1 I2
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_OR3


.SUBCKT X3_OR4  I0 P0 I1 P1 I2 P2 I3 P3 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 OUT_D=0

U1 LOGICEXP(9,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) | (I1^P1) | (I2^P2) | (I3^P3) ) }

U2 PINDLY(1,0,4) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_OR4


.SUBCKT X3_OR5  I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 I4_D=0 OUT_D=0

U1 LOGICEXP(11,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) | (I1^P1) | (I2^P2) | (I3^P3) | (I4^P4) ) }

U2 PINDLY(1,0,5) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3 I4
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 CHANGED(I4,0), DELAY(I4_D+OUT_D,-1,I4_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_OR5

*$

.SUBCKT X3_TBUF  IN T OUT TDLY
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: IN_D=0 TLH_D=0 THL_D=0 OUT_D=0
*
* XILINX 3-states enables are active low
* The TDLY signal is available as an output to allow for
* proper timing of externally-connected PULLUP devices.

UTDLY BUF DPWR DGND T TDLY X3_TBUF_TDLY IO_X3000
UTDLYBAR INV DPWR DGND T TDLYBAR X3_TBUF_T IO_X3000

.MODEL X3_TBUF_TDLY UGATE(
+  TPLHMN={TLH_D} TPHLMN={THL_D}
+  TPLHMX={TLH_D} TPHLMX={THL_D}
+  )

.MODEL X3_TBUF_T UGATE(
+  TPLHMN={THL_D} TPHLMN={TLH_D}	; lh/hl swapped intentionally
+  TPLHMX={THL_D} TPHLMX={TLH_D}
+  )

UIDLY BUF DPWR DGND IN INDLY X3_TBUF_IN IO_X3000
.MODEL X3_TBUF_IN UGATE(
+  TPLHMN={IN_D+OUT_D} TPHLMN={IN_D+OUT_D} 
+  TPLHMX={IN_D+OUT_D} TPHLMX={IN_D+OUT_D} 
+  )

UOUT BUF3 DPWR DGND 
+ INDLY TDLYBAR OUT
+ D0_TGATE
+ IO_X3000

.ENDS X3_TBUF

*$

.SUBCKT X3_XNOR2  I0 P0 I1 P1 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 OUT_D=0

U1 LOGICEXP(5,1) DPWR DGND 
+ I0 P0 I1 P1 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~( (I0^P0) ^ (I1^P1) ) }

U2 PINDLY(1,0,2) DPWR DGND
+ OUT_INT
+ I0 I1
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_XNOR2

*$

.SUBCKT X3_XNOR3  I0 P0 I1 P1 I2 P2  OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 OUT_D=0

U1 LOGICEXP(7,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~ ( (I0^P0) ^ (I1^P1) ^ (I2^P2)) }

U2 PINDLY(1,0,3) DPWR DGND
+ OUT_INT
+ I0 I1 I2
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+                CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_XNOR3

*$

.SUBCKT X3_XNOR4  I0 P0 I1 P1 I2 P2 I3 P3 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 OUT_D=0

U1 LOGICEXP(9,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~ ( (I0^P0) ^ (I1^P1) ^ (I2^P2) ^ (I3^P3) ) }

U2 PINDLY(1,0,4) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_XNOR4

*$

.SUBCKT X3_XNOR5  I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 I4_D=0 OUT_D=0

U1 LOGICEXP(11,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ~ ( (I0^P0) ^ (I1^P1) ^ (I2^P2) ^ (I3^P3) ^ (I4^P4) ) }

U2 PINDLY(1,0,5) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3 I4
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 CHANGED(I4,0), DELAY(I4_D+OUT_D,-1,I4_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_XNOR5

*$

.SUBCKT X3_XOR2  I0 P0 I1 P1 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 OUT_D=0

U1 LOGICEXP(5,1) DPWR DGND 
+ I0 P0 I1 P1 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) ^ (I1^P1) ) }

U2 PINDLY(1,0,2) DPWR DGND
+ OUT_INT
+ I0 I1
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_XOR2

*$

.SUBCKT X3_XOR3  I0 P0 I1 P1 I2 P2  OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 OUT_D=0

U1 LOGICEXP(7,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) ^ (I1^P1) ^ (I2^P2)) }

U2 PINDLY(1,0,3) DPWR DGND
+ OUT_INT
+ I0 I1 I2
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+                CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_XOR3

*$

.SUBCKT X3_XOR4  I0 P0 I1 P1 I2 P2 I3 P3 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 OUT_D=0

U1 LOGICEXP(9,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) ^ (I1^P1) ^ (I2^P2) ^ (I3^P3) ) }

U2 PINDLY(1,0,4) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_XOR4

*$

.SUBCKT X3_XOR5  I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 OUT PO
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: I0_D=0 I1_D=0 I2_D=0 I3_D=0 I4_D=0 OUT_D=0

U1 LOGICEXP(11,1) DPWR DGND 
+ I0 P0 I1 P1 I2 P2 I3 P3 I4 P4 PO OUT_INT
+ D0_GATE
+ IO_X3000
+ LOGIC:
+   OUT_INT = {PO ^ ( (I0^P0) ^ (I1^P1) ^ (I2^P2) ^ (I3^P3) ^ (I4^P4) ) }

U2 PINDLY(1,0,5) DPWR DGND
+ OUT_INT
+ I0 I1 I2 I3 I4
+ OUT
+ IO_X3000
+ PINDLY:
+   OUT = {CASE( CHANGED(I0,0), DELAY(I0_D+OUT_D,-1,I0_D+OUT_D),
+                CHANGED(I1,0), DELAY(I1_D+OUT_D,-1,I1_D+OUT_D),
+		 CHANGED(I2,0), DELAY(I2_D+OUT_D,-1,I2_D+OUT_D),
+		 CHANGED(I3,0), DELAY(I3_D+OUT_D,-1,I3_D+OUT_D),
+		 CHANGED(I4,0), DELAY(I4_D+OUT_D,-1,I4_D+OUT_D),
+		 DELAY(0,0,0) ) }

.ENDS X3_XOR5

*$

.SUBCKT X3_OFD GR CLK PCLK D PD Q PQ
+ OPTIONAL:  DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: GR_D=0 CLK_D=0 D_D=0 Q_D=0
+   D_CLK_SETUP=0       D_CLK_HOLD=0
+   GR_CLK_SETUP=0     GR_CLK_HOLD=0
+   CLK_WIDTH=0 GR_WIDTH=0

UD XOR DPWR DGND
+ D PD   D_BUF
+ X3_OFD_D 
+ IO_X3000

.MODEL X3_OFD_D UGATE (
+   TPLHMN={D_D} TPLHMX={D_D}
+   TPHLMN={D_D} TPHLMX={D_D}
+   )

UCLK XOR DPWR DGND
+ CLK PCLK CLK_BUF
+ X3_OFD_CLK 
+ IO_X3000

.MODEL X3_OFD_CLK UGATE (
+   TPLHMN={CLK_D} TPLHMX={CLK_D}
+   TPHLMN={CLK_D} TPHLMX={CLK_D}
+   )

UGR BUF DPWR DGND
+ GR GR_BUF
+ X3_OFD_GR 
+ IO_X3000

.MODEL X3_OFD_GR UGATE (
+   TPLHMN={GR_D} TPLHMX={GR_D}
+   TPHLMN={GR_D} TPHLMX={GR_D}
+   )

UDFF DFF(1) DPWR DGND
+ $D_HI GR_BUF CLK_BUF D_BUF Q_INT1 $D_NC
+ D0_EFF
+ IO_X3000

UQPOL XOR() DPWR DGND
+ Q_INT2 PQ   Q
+ D0_GATE
+ IO_X3000

UDELAY PINDLY(1,0,5) DPWR DGND
+ Q_INT1
+ CLK CLK_BUF D_BUF GR GR_BUF
+ Q_INT2
+ IO_X3000
+ PINDLY:
+   Q_INT2 = {DELAY(Q_D,-1,Q_D)}
+ SETUP_HOLD:
+   CLOCK LH = CLK_BUF
+   DATA(1) = D_BUF
+   SETUPTIME = {D_CLK_SETUP}
+   HOLDTIME =  {D_CLK_HOLD}
+   WHEN = {GR_BUF == '1 }
+ WIDTH:
+   NODE = CLK
+   MIN_HI = {CLK_WIDTH}
+   MIN_LO = {CLK_WIDTH}
+ WIDTH:
+   NODE = GR
+   MIN_LO = {GR_WIDTH}

.ENDS X3_OFD

*$

.SUBCKT X3_OFDT GR CLK PCLK T PT D PD O PO
+ OPTIONAL:  DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: GR_D=0 CLK_D=0 T_RISED=0 T_FALLD=0 D_D=0 O_D=0
+   D_CLK_SETUP=0      D_CLK_HOLD=0
+   GR_CLK_SETUP=0     GR_CLK_HOLD=0
+   CLK_WIDTH=0 GR_WIDTH=0

UD XOR DPWR DGND
+ D PD   D_BUF
+ X3_OFDT_D 
+ IO_X3000

UT NXOR DPWR DGND
+ T PT   T_BUF
+ X3_OFDT_T 
+ IO_X3000


.MODEL X3_OFDT_D UGATE (
+   TPLHMN={D_D} TPLHMX={D_D}
+   TPHLMN={D_D} TPHLMX={D_D}
+   )

.MODEL X3_OFDT_T UGATE (
+   TPHLMN={T_FALLD} TPHLMX={T_FALLD}
+   TPLHMN={T_RISED} TPLHMX={T_RISED}
+   )

UCLK XOR DPWR DGND
+ CLK PCLK CLK_BUF
+ X3_OFDT_CLK 
+ IO_X3000

.MODEL X3_OFDT_CLK UGATE (
+   TPLHMN={CLK_D} TPLHMX={CLK_D}
+   TPHLMN={CLK_D} TPHLMX={CLK_D}
+   )

UGR BUF DPWR DGND
+ GR GR_BUF
+ X3_OFDT_GR 
+ IO_X3000

.MODEL X3_OFDT_GR UGATE (
+   TPLHMN={GR_D} TPLHMX={GR_D}
+   TPHLMN={GR_D} TPHLMX={GR_D}
+   )

UDFF DFF(1) DPWR DGND
+ $D_HI GR_BUF CLK_BUF D_BUF O_INT1 $D_NC
+ D0_EFF
+ IO_X3000

UOPOL XOR() DPWR DGND
+ O_INT2 PO   OINT
+ D0_GATE
+ IO_X3000

UOTS BUF3() DPWR DGND
+ OINT T_BUF  O
+ D0_TGATE
+ IO_X3000

UDELAY PINDLY(1,0,5) DPWR DGND
+ O_INT1
+ CLK CLK_BUF D_BUF GR GR_BUF
+ O_INT2
+ IO_X3000
+ PINDLY:
+   O_INT2 = {DELAY(O_D,-1,O_D)}
+ SETUP_HOLD:
+   CLOCK LH = CLK_BUF
+   DATA(1) = D_BUF
+   SETUPTIME = {D_CLK_SETUP}
+   HOLDTIME =  {D_CLK_HOLD}
+   WHEN = {GR_BUF == '1 }
+ WIDTH:
+   NODE = CLK
+   MIN_HI = {CLK_WIDTH}
+   MIN_LO = {CLK_WIDTH}
+ WIDTH:
+   NODE = GR
+   MIN_LO = {GR_WIDTH}

.ENDS X3_OFDT

*$

.SUBCKT X3_INFF GR CLK PCLK D Q
+ OPTIONAL:  DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: GR_D=0 CLK_D=0 D_D=0 Q_D=0
+   D_CLK_SETUP=0       D_CLK_HOLD=0
+   GR_CLK_SETUP=0     GR_CLK_HOLD=0
+   CLK_WIDTH=0 GR_WIDTH=0


UD BUF DPWR DGND
+ D   D_BUF
+ X3_INFF_D 
+ IO_X3000

.MODEL X3_INFF_D UGATE (
+   TPLHMN={D_D} TPLHMX={D_D}
+   TPHLMN={D_D} TPHLMX={D_D}
+   )

UCLK XOR DPWR DGND
+ CLK PCLK CLK_BUF
+ X3_INFF_CLK 
+ IO_X3000

.MODEL X3_INFF_CLK UGATE (
+   TPLHMN={CLK_D} TPLHMX={CLK_D}
+   TPHLMN={CLK_D} TPHLMX={CLK_D}
+   )

UGR BUF DPWR DGND
+ GR  GR_BUF
+ X3_INFF_GR 
+ IO_X3000

.MODEL X3_INFF_GR UGATE (
+   TPLHMN={GR_D} TPLHMX={GR_D}
+   TPHLMN={GR_D} TPHLMX={GR_D}
+   )

UDFF DFF(1) DPWR DGND
+ $D_HI GR_BUF CLK_BUF D_BUF Q_INT $D_NC
+ D0_EFF
+ IO_X3000

UQPOL XOR() DPWR DGND
+ Q_OUT PQ   Q
+ D0_GATE
+ IO_X3000

UDELAY PINDLY(1,0,5) DPWR DGND
+ Q_INT
+ CLK CLK_BUF D_BUF GR GR_BUF
+ Q_OUT
+ IO_X3000
+ PINDLY:
+   Q_OUT = {DELAY(Q_D,-1,Q_D)}
+ SETUP_HOLD:
+   CLOCK LH = CLK_BUF
+   DATA(1) = D_BUF
+   SETUPTIME = {D_CLK_SETUP}
+   HOLDTIME =  {D_CLK_HOLD}
+   WHEN = {GR_BUF == '1 }
+ WIDTH:
+   NODE = CLK
+   MIN_HI = {CLK_WIDTH}
+   MIN_LO = {CLK_WIDTH}
+ WIDTH:
+   NODE = GR
+   MIN_LO = {GR_WIDTH}

.MODEL X3_INFF_Q UEFF (
+  TPCLKQLHMN={Q_D} TPCLKQLHMX={Q_D}
+  TPCLKQHLMN={Q_D} TPCLKQHLMX={Q_D}
+  )

.ENDS X3_INFF

*$

.SUBCKT X3_INLAT GR G PG D Q
+ OPTIONAL:  DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: GR_D=0 G_D=0 D_D=0 Q_D=0
+   D_G_SETUP=0       D_G_HOLD=0
+   GR_G_SETUP=0     GR_G_HOLD=0
+   G_WIDTH=0 GR_WIDTH=0

UD BUF DPWR DGND
+ D  D_BUF
+ X3_INLAT_D 
+ IO_X3000

.MODEL X3_INLAT_D UGATE (
+   TPLHMN={D_D} TPLHMX={D_D}
+   TPHLMN={D_D} TPHLMX={D_D}
+   )

UGATE NXOR DPWR DGND
+ G PG G_BUF
+ X3_INLAT_G 
+ IO_X3000

.MODEL X3_INLAT_G UGATE (
+   TPLHMN={G_D} TPLHMX={G_D}
+   TPHLMN={G_D} TPHLMX={G_D}
+   )

UGR INV DPWR DGND
+ GR  GR_BUF
+ X3_INLAT_GR 
+ IO_X3000

.MODEL X3_INLAT_GR UGATE (
+   TPLHMN={GR_D} TPLHMX={GR_D}
+   TPHLMN={GR_D} TPHLMX={GR_D}
+   )

UDLAT DLTCH(1) DPWR DGND
+ $D_HI GR_BUF G_BUF D_BUF Q_INT $D_NC
+ D0_GFF
+ IO_X3000

UDELAY PINDLY(1,0,5) DPWR DGND
+ Q_INT
+ G G_BUF D_BUF GR GR_BUF
+ Q
+ IO_X3000
+ PINDLY:
+   Q = {DELAY(Q_D,-1,Q_D)}
+ SETUP_HOLD:
+   CLOCK LH = G_BUF
+   DATA(1) = D_BUF
+   SETUPTIME = {D_G_SETUP}
+   HOLDTIME =  {D_G_HOLD}
+   WHEN = {GR_BUF == '1 }
+ WIDTH:
+   NODE = G
+   MIN_HI = {G_WIDTH}
+   MIN_LO = {G_WIDTH}
+ WIDTH:
+   NODE = GR
+   MIN_LO = {GR_WIDTH}

.MODEL X3_INLAT_Q UGFF (
+  TPGQLHMN={Q_D} TPGQLHMX={Q_D}
+  TPGQHLMN={Q_D} TPGQHLMX={Q_D}
+  )

.ENDS X3_INLAT

*$

.SUBCKT X3_PULLUP SIG ENB PENB
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS
+ PARAMS: PULLUP_D=0

.MODEL BTG1 UBTG

.MODEL ENB_GATE UGATE
+  TPLHMN={PULLUP_D} TPHLMN={PULLUP_D} 
+  TPLHMX={PULLUP_D} TPHLMX={PULLUP_D} 
+  )

UEDLY XOR DPWR DGND
+ ENB PENB  ENBDLY
+ ENB_GATE
+ IO_X3000

UBTG NBTG DPWR DGND
+ ENBDLY PULLUPNODE SIG
+ BTG1 IO_X3000

U1 PULLUP(1) DPWR DGND
+ PULLUPNODE
+ IO_X3000_PULLUP

.ENDS X3_PULLUP

*$

.SUBCKT X3_PULLDOWN SIG
+ OPTIONAL: DPWR=$G_X3000_VDD DGND=$G_X3000_VSS

U1 PULLDN(1) DPWR DGND
+ SIG
+ IO_X3000

.ENDS X3_PULLDOWN

*$

